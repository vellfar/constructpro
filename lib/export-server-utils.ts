// Server-side CSV export utility
export function jsonToCsv(data: any): string {
  const arr = Array.isArray(data) ? data : [data]
  if (arr.length === 0) return ""
  const keys = Object.keys(arr[0])
  const csvRows = [keys.join(",")]
  for (const row of arr) {
    csvRows.push(keys.map((k) => JSON.stringify(row[k] ?? "")).join(","))
  }
  return csvRows.join("\n")
}

// Server-side PDF export utility (simple, text-based)
import PDFDocument from "pdfkit"
import path from "path"
import fs from "fs"
export async function jsonToPdfBuffer(data: any, title = "Report"): Promise<Buffer> {
  // Professional branding and layout
  const doc = new PDFDocument({ font: path.join(process.cwd(), "public", "fonts", "Roboto-Regular.ttf") })
  const chunks: Buffer[] = []
  doc.on("data", (chunk: Buffer) => chunks.push(chunk))
  doc.on("end", () => {})

  // Add logo if available
  const logoPath = path.join(process.cwd(), "public", "placeholder-logo.png")
  if (fs.existsSync(logoPath)) {
    doc.image(logoPath, doc.page.width / 2 - 40, 30, { width: 80 })
    doc.moveDown(2)
  }

  // Header
  doc.fontSize(22).fillColor('#1a237e').text(title, { align: "center" })
  doc.moveDown(0.5)
  doc.fontSize(12).fillColor('#333').text(`Generated: ${new Date().toLocaleString()}`, { align: "center" })
  doc.moveDown(1.5)

  // Draw a line
  doc.moveTo(50, doc.y).lineTo(doc.page.width - 50, doc.y).stroke('#1a237e')
  doc.moveDown(1.5)

  // --- Report Summary Section ---
  doc.fontSize(14).fillColor('#1a237e').text('Report Summary', { underline: true })
  doc.moveDown(0.5)
  // Extract common parameters if present
  const params: Record<string, any> = {}
  if (data && typeof data === 'object') {
    // Common report params
    if (data.dateFrom) params['Date From'] = data.dateFrom
    if (data.dateTo) params['Date To'] = data.dateTo
    if (data.projectId) params['Project'] = data.projectId
    if (data.projectName) params['Project Name'] = data.projectName
    if (data.type) params['Type'] = data.type
    if (data.parameters) Object.assign(params, data.parameters)
  }
  Object.entries(params).forEach(([k, v]) => {
    doc.fontSize(11).fillColor('#222').text(`${k}: ${v}`)
  })
  if (Object.keys(params).length > 0) doc.moveDown(1)

  // --- Main Data Sections ---
  if (data && typeof data === 'object') {
    // For each top-level key, render as a section
    for (const [key, value] of Object.entries(data)) {
      // Skip parameters already shown
      if (["dateFrom","dateTo","projectId","projectName","type","parameters"].includes(key)) continue
      doc.fontSize(13).fillColor('#1a237e').text(key.replace(/([A-Z])/g, ' $1').replace(/^./, s => s.toUpperCase()), { underline: true })
      doc.moveDown(0.2)
      if (Array.isArray(value) && value.length > 0 && typeof value[0] === 'object') {
        // Render as table
        const keys = Object.keys(value[0])
        // Table header
        doc.fontSize(11).fillColor('#3949ab').text(keys.join(' | '), { align: 'left' })
        doc.moveDown(0.1)
        doc.fontSize(10).fillColor('#222')
        value.forEach((row: any) => {
          doc.text(keys.map((k) => String(row[k] ?? '')).join(' | '), { align: 'left' })
        })
        doc.moveDown(0.5)
      } else if (typeof value === 'object' && value !== null) {
        // Render as pretty JSON
        doc.fontSize(10).fillColor('#222').text(JSON.stringify(value, null, 2), { align: 'left' })
        doc.moveDown(0.5)
      } else {
        // Render as simple value
        doc.fontSize(11).fillColor('#222').text(String(value), { align: 'left' })
        doc.moveDown(0.5)
      }
    }
  } else {
    // Fallback: just print the data
    doc.fontSize(10).fillColor('#222').text(String(data), { align: 'left' })
  }

  // Footer
  doc.moveDown(2)
  doc.fontSize(10).fillColor('#888').text('Generated by Construction Management System', 50, doc.page.height - 50, {
    align: 'center',
  })

  doc.end()
  return await new Promise((resolve) => {
    doc.on("end", () => {
      resolve(Buffer.concat(chunks))
    })
  })
}
